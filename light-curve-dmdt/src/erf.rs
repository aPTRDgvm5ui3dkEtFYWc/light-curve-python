use crate::float_trait::Float;
use conv::*;

impl Default for ErrorFunction {
    fn default() -> Self {
        Self::Direct
    }
}

impl ErrorFunction {
    pub fn erf<T>(&self, x: T) -> T
    where
        T: Float + LibMFloat + ErfEps1Over1e3Float,
    {
        match self {
            Self::Direct => x.libm_erf(),
            Self::Eps1Over1e3 => x.erf_eps_1over1e3(),
        }
    }

    pub fn normal_cdf<T>(&self, x: T, mean: T, w: T) -> T
    where
        T: Float + LibMFloat + ErfEps1Over1e3Float,
    {
        let inv_sigma = T::sqrt(w);
        T::half() * (T::one() + self.erf((x - mean) * inv_sigma * T::FRAC_1_SQRT_2()))
    }
}

pub trait LibMFloat {
    fn libm_erf(self) -> Self;
}

impl LibMFloat for f32 {
    fn libm_erf(self) -> Self {
        libm::erff(self)
    }
}

impl LibMFloat for f64 {
    fn libm_erf(self) -> Self {
        libm::erf(self)
    }
}

pub enum ErrorFunction {
    Direct,
    Eps1Over1e3,
}

pub trait ErfEps1Over1e3Float: ApproxInto<usize, RoundToZero> + num_traits::Float {
    const X_FOR_ERF_EPS_1OVER1E3: [Self; 64];
    const INVERSED_DX_FOR_ERF_EPS_1OVER1E3: Self;
    const Y_FOR_ERF_EPS_1OVER1E3: [Self; 64];
    fn erf_eps_1over1e3(self) -> Self {
        match self {
            _ if self < Self::X_FOR_ERF_EPS_1OVER1E3[0] => -Self::one(),
            _ if self >= Self::X_FOR_ERF_EPS_1OVER1E3[63] => Self::one(),
            x => {
                let idx =
                    (x - Self::X_FOR_ERF_EPS_1OVER1E3[0]) * Self::INVERSED_DX_FOR_ERF_EPS_1OVER1E3;
                let alpha = idx.fract();
                let idx: usize = idx.approx_by::<RoundToZero>().unwrap();
                Self::Y_FOR_ERF_EPS_1OVER1E3[idx] * (Self::one() - alpha)
                    + Self::Y_FOR_ERF_EPS_1OVER1E3[idx + 1] * alpha
            }
        }
    }
}

impl ErfEps1Over1e3Float for f32 {
    const X_FOR_ERF_EPS_1OVER1E3: [Self; 64] = [
        -2.5,
        -2.42063492,
        -2.34126984,
        -2.26190476,
        -2.18253968,
        -2.1031746,
        -2.02380952,
        -1.94444444,
        -1.86507937,
        -1.78571429,
        -1.70634921,
        -1.62698413,
        -1.54761905,
        -1.46825397,
        -1.38888889,
        -1.30952381,
        -1.23015873,
        -1.15079365,
        -1.07142857,
        -0.99206349,
        -0.91269841,
        -0.83333333,
        -0.75396825,
        -0.67460317,
        -0.5952381,
        -0.51587302,
        -0.43650794,
        -0.35714286,
        -0.27777778,
        -0.1984127,
        -0.11904762,
        -0.03968254,
        0.03968254,
        0.11904762,
        0.1984127,
        0.27777778,
        0.35714286,
        0.43650794,
        0.51587302,
        0.5952381,
        0.67460317,
        0.75396825,
        0.83333333,
        0.91269841,
        0.99206349,
        1.07142857,
        1.15079365,
        1.23015873,
        1.30952381,
        1.38888889,
        1.46825397,
        1.54761905,
        1.62698413,
        1.70634921,
        1.78571429,
        1.86507937,
        1.94444444,
        2.02380952,
        2.1031746,
        2.18253968,
        2.26190476,
        2.34126984,
        2.42063492,
        2.5,
    ];
    const INVERSED_DX_FOR_ERF_EPS_1OVER1E3: Self = 12.6;
    const Y_FOR_ERF_EPS_1OVER1E3: [Self; 64] = [
        -0.99959305,
        -0.99938133,
        -0.99907055,
        -0.99862007,
        -0.99797525,
        -0.99706379,
        -0.99579154,
        -0.99403792,
        -0.99165101,
        -0.98844272,
        -0.98418435,
        -0.97860289,
        -0.97137872,
        -0.96214531,
        -0.95049142,
        -0.93596647,
        -0.91808955,
        -0.89636226,
        -0.87028553,
        -0.83938007,
        -0.80320978,
        -0.76140717,
        -0.71369936,
        -0.65993304,
        -0.60009661,
        -0.53433753,
        -0.46297332,
        -0.38649473,
        -0.3055602,
        -0.2209812,
        -0.13369895,
        -0.04475346,
        0.04475346,
        0.13369895,
        0.2209812,
        0.3055602,
        0.38649473,
        0.46297332,
        0.53433753,
        0.60009661,
        0.65993304,
        0.71369936,
        0.76140717,
        0.80320978,
        0.83938007,
        0.87028553,
        0.89636226,
        0.91808955,
        0.93596647,
        0.95049142,
        0.96214531,
        0.97137872,
        0.97860289,
        0.98418435,
        0.98844272,
        0.99165101,
        0.99403792,
        0.99579154,
        0.99706379,
        0.99797525,
        0.99862007,
        0.99907055,
        0.99938133,
        0.99959305,
    ];
}

impl ErfEps1Over1e3Float for f64 {
    const X_FOR_ERF_EPS_1OVER1E3: [Self; 64] = [
        -2.5,
        -2.42063492,
        -2.34126984,
        -2.26190476,
        -2.18253968,
        -2.1031746,
        -2.02380952,
        -1.94444444,
        -1.86507937,
        -1.78571429,
        -1.70634921,
        -1.62698413,
        -1.54761905,
        -1.46825397,
        -1.38888889,
        -1.30952381,
        -1.23015873,
        -1.15079365,
        -1.07142857,
        -0.99206349,
        -0.91269841,
        -0.83333333,
        -0.75396825,
        -0.67460317,
        -0.5952381,
        -0.51587302,
        -0.43650794,
        -0.35714286,
        -0.27777778,
        -0.1984127,
        -0.11904762,
        -0.03968254,
        0.03968254,
        0.11904762,
        0.1984127,
        0.27777778,
        0.35714286,
        0.43650794,
        0.51587302,
        0.5952381,
        0.67460317,
        0.75396825,
        0.83333333,
        0.91269841,
        0.99206349,
        1.07142857,
        1.15079365,
        1.23015873,
        1.30952381,
        1.38888889,
        1.46825397,
        1.54761905,
        1.62698413,
        1.70634921,
        1.78571429,
        1.86507937,
        1.94444444,
        2.02380952,
        2.1031746,
        2.18253968,
        2.26190476,
        2.34126984,
        2.42063492,
        2.5,
    ];
    const INVERSED_DX_FOR_ERF_EPS_1OVER1E3: Self = 12.6;
    const Y_FOR_ERF_EPS_1OVER1E3: [Self; 64] = [
        -0.99959305,
        -0.99938133,
        -0.99907055,
        -0.99862007,
        -0.99797525,
        -0.99706379,
        -0.99579154,
        -0.99403792,
        -0.99165101,
        -0.98844272,
        -0.98418435,
        -0.97860289,
        -0.97137872,
        -0.96214531,
        -0.95049142,
        -0.93596647,
        -0.91808955,
        -0.89636226,
        -0.87028553,
        -0.83938007,
        -0.80320978,
        -0.76140717,
        -0.71369936,
        -0.65993304,
        -0.60009661,
        -0.53433753,
        -0.46297332,
        -0.38649473,
        -0.3055602,
        -0.2209812,
        -0.13369895,
        -0.04475346,
        0.04475346,
        0.13369895,
        0.2209812,
        0.3055602,
        0.38649473,
        0.46297332,
        0.53433753,
        0.60009661,
        0.65993304,
        0.71369936,
        0.76140717,
        0.80320978,
        0.83938007,
        0.87028553,
        0.89636226,
        0.91808955,
        0.93596647,
        0.95049142,
        0.96214531,
        0.97137872,
        0.97860289,
        0.98418435,
        0.98844272,
        0.99165101,
        0.99403792,
        0.99579154,
        0.99706379,
        0.99797525,
        0.99862007,
        0.99907055,
        0.99938133,
        0.99959305,
    ];
}

#[cfg(test)]
mod tests {
    use super::*;
    use approx::assert_abs_diff_eq;
    use ndarray::Array1;

    #[test]
    fn erf_eps_1over1e3() {
        let x = Array1::linspace(-5.0, 5.0, 1 << 20);
        let desired = x.mapv(f32::libm_erf);
        let actual = x.mapv(f32::erf_eps_1over1e3);
        assert_abs_diff_eq!(
            actual.as_slice().unwrap(),
            desired.as_slice().unwrap(),
            epsilon = 1e-3,
        );
    }
}
